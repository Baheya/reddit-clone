{"ast":null,"code":"import { cacheExchange } from '@urql/exchange-graphcache';\nimport gql from 'graphql-tag';\nimport { dedupExchange, fetchExchange } from 'urql';\nimport { pipe, tap } from 'wonka';\nimport { MeDocument } from '../generated/graphql';\nimport { betterUpdateQuery } from './betterUpdateQuery';\nimport Router from 'next/router';\nimport { stringifyVariables } from '@urql/core';\nimport { isServer } from './isServer';\n\nconst cursorPagination = () => {\n  return (_parent, fieldArgs, cache, info) => {\n    const {\n      parentKey: entityKey,\n      fieldName\n    } = info;\n    const allFields = cache.inspectFields(entityKey);\n    const fieldInfos = allFields.filter(info => info.fieldName === fieldName);\n    const size = fieldInfos.length;\n\n    if (size === 0) {\n      return undefined;\n    }\n\n    const fieldKey = `${fieldName}(${stringifyVariables(fieldArgs)})`;\n    const isInCache = cache.resolve(cache.resolveFieldByKey(entityKey, fieldKey), 'posts');\n    info.partial = !isInCache;\n    let hasMore = true;\n    const results = [];\n    fieldInfos.forEach(fi => {\n      const key = cache.resolveFieldByKey(entityKey, fi.fieldKey);\n      const data = cache.resolve(key, 'posts');\n\n      const _hasMore = cache.resolve(key, 'hasMore');\n\n      if (_hasMore) {\n        hasMore = _hasMore;\n      }\n\n      results.push(...data);\n    });\n    return {\n      __typename: 'PaginatedPosts',\n      hasMore,\n      posts: results\n    };\n  };\n};\n\nexport const errorExchange = ({\n  forward\n}) => ops$ => {\n  return pipe(forward(ops$), tap(({\n    error\n  }) => {\n    if (error === null || error === void 0 ? void 0 : error.message.includes('not authenticated')) {\n      Router.replace('/');\n    }\n  }));\n};\n\nfunction invalidateAllPosts(cache) {\n  const allFields = cache.inspectFields('Query');\n  const fieldInfos = allFields.filter(info => info.fieldName === 'posts');\n  fieldInfos.forEach(fi => {\n    cache.invalidate('Query', 'posts', fi.arguments || {});\n  });\n}\n\nexport const createUrqlClient = (ssrExchange, ctx) => {\n  let cookie = '';\n\n  if (isServer()) {\n    var _ctx$req, _ctx$req$headers;\n\n    cookie = ctx === null || ctx === void 0 ? void 0 : (_ctx$req = ctx.req) === null || _ctx$req === void 0 ? void 0 : (_ctx$req$headers = _ctx$req.headers) === null || _ctx$req$headers === void 0 ? void 0 : _ctx$req$headers.cookie;\n    console.log(cookie);\n  }\n\n  return {\n    url: process.env.NEXT_PUBLIC_API_URL,\n    fetchOptions: {\n      credentials: 'include',\n      headers: cookie ? {\n        cookie\n      } : undefined\n    },\n    exchanges: [dedupExchange, cacheExchange({\n      keys: {\n        PaginatedPosts: () => null\n      },\n      resolvers: {\n        Query: {\n          posts: cursorPagination()\n        }\n      },\n      updates: {\n        Mutation: {\n          deletePost: (_result, args, cache, _info) => {\n            cache.invalidate({\n              __typename: 'Post',\n              id: args.id\n            });\n          },\n          vote: (_result, args, cache, _info) => {\n            const {\n              postId,\n              value\n            } = args;\n            const data = cache.readFragment(gql`\n                  fragment _ on Post {\n                    id\n                    votes\n                    voteStatus\n                  }\n                `, {\n              id: postId\n            });\n\n            if (data) {\n              if (data.voteStatus === value) {\n                return;\n              }\n\n              const newVotes = data.votes + (!data.voteStatus ? 1 : 2) * value;\n              cache.writeFragment(gql`\n                    fragment __ on Post {\n                      votes\n                      voteStatus\n                    }\n                  `, {\n                id: postId,\n                votes: newVotes,\n                voteStatus: value\n              });\n            }\n          },\n          createPost: (_result, _args, cache, _info) => {\n            invalidateAllPosts(cache);\n          },\n          logout: (_result, _args, cache, _info) => {\n            betterUpdateQuery(cache, {\n              query: MeDocument\n            }, _result, () => ({\n              me: null\n            }));\n          },\n          login: (_result, _args, cache, _info) => {\n            betterUpdateQuery(cache, {\n              query: MeDocument\n            }, _result, (result, query) => {\n              if (result.login.errors) {\n                return query;\n              } else {\n                return {\n                  me: result.login.user\n                };\n              }\n            });\n            invalidateAllPosts(cache);\n          },\n          register: (_result, _args, cache, _info) => {\n            betterUpdateQuery(cache, {\n              query: MeDocument\n            }, _result, (result, query) => {\n              if (result.register.errors) {\n                return query;\n              } else {\n                return {\n                  me: result.register.user\n                };\n              }\n            });\n          }\n        }\n      }\n    }), errorExchange, ssrExchange, fetchExchange]\n  };\n};","map":null,"metadata":{},"sourceType":"module"}